##

1. 증권형 토큰의 개념
2. openzeppelin: ERC20 발행
3. chainlink price feed
3. openzeppelin: AccessControl
4. openzeppelin: Pausable

##

자산 유동화에 대한 소개 및 컨트랙트 설계

1. 자산 유동화 토큰 발행 및 구매 컨트랙트

hardhat을 이용해서 개발할 컨트랙트는 엘리시아의 asset token 컨트랙트를 단순화시킨 형태이다. asset token 컨트랙트의 소스코드는 여기서 확인할 수 있다.

자산 유동화를 하고, 유동화 시킨 자산을 구입할 수 있는 간단한 컨트랙트를 작성해보자.


이 간단한 컨트랙트의 배경은 다음과 같다.

철수는 100억원짜리 부동산을 가지고 있다. 그는 당장 30억원이 필요하고, 이 부동산을 판매하는 일이 있더라도 30억원을 구해야 한다. 그러나 이 정도 규모의 부동산을 빠른 시일 내에 현금이나 다른 가치로 교환하는 것은 쉽지 않다. 게다가 그는 이 건물을 통채로 팔고 싶지 않다! 즉 철수는 유동성이 떨어지는 부동산의 특징으로 인해 여러 가지 문제를 겪고 있는 상황이다.

이러한 문제를 해결하고 자산을 유동화 시킬 수 있는 방법으로, 철수는 블록체인을 선택했다.
철수는 이 부동산에 대한 소유권(채권이라 볼 수도 있다)을 보장하는 토큰을 발행하여, 자산을 유동화 시키고자 한다. 철수는 부동산에 대해 10000개의 토큰을 발행할 계획이며,  사람들에게 판매하고자 한다. 이 토큰을 소유한다는 것은 철수의 부동산을 일부 소유하고 있다는 사실과 동일하다. 이에 대한 사실은 은행과 같은 제3기관이 보증한다. 철수가 발행한 토큰 1개는 100억 / 10000개 = 100만원의 고정된 가치를 가진다.

자산 유동화의 개념 및 우리가 진행할 프로젝트에 대한 간략한 소개를 마쳤다. 사실 이 개념은 '증권형 토큰'에서 출발했다. 증권형 토큰이란 말 그대로 증권의 성격을 갖는 토큰을 의미한다. 현실에 존재하는, 혹은 가상의 자산을 토큰화 시키고 자산에 토큰을 페깅한 자산을 의미한다. 증권의 성격을 갖기 때문에 소유자는 주주처럼 배당금 받거나 분할된 권리을 가질 수 있다.

단순화를 위해 우리가 구현할 컨트랙트는 '권리'에 대한 부분은 제외시켰다. 가장 기초적이고 단순한 증권형 토큰이라고 할 수 있겠다. 이런 기능을 구현하기 위해 우리의 컨트랙트가 가져야 할 spec은 아래와 같다.

1. 토큰 발행
부동산 자산을 유동화 시키는 만큼, 자산을 분할한 토큰을 발행해야 한다.
2. 토큰 교환 기능
자산 토큰을 교환할 수 있는 기능이 필요하다. 고객은 ether를 이용하여 자산 토큰을 구매할 수 있다.
3. 가격 오라클 기능
자산 토큰의 가격이 고정된 반면, 구매를 위한 화폐인 ether의 가격은 거래소 상황에 따라 계속 변동된다. 이에 따라 chainlink를 이용해서 price oracle을 작성할 것이다. 이 oracle은 거래소를 통해 받아온 가격 정보(off chain data)를 우리의 컨트랙트(on chain)에게 전해주는 역할을 하게 된다.
4. 특정 계정에 대한 구매 허용, 또는 차단 기능
일반적인 증권은 아무나 보유할 수 없다. 불법 자금 세탁 등에 이용될 수 있기 때문이다. 이에 따라 여러 증권형 토큰 프로젝트에서는 KYC(Know your customer) 절차를 통해 인증된 계정에 한해 증권의 거래를 허용한다.
5. 구매 중단 기능
철수는 사람들이 특정 양의 자산 토큰을 구매한 시점에 토큰 구매 기능을 중단시키고 싶다. 이를 설정할 수 있는 기능이 필요하다.

하나하나 구현해 보도록 하자.



###

1. 토큰 발행

우리가 만들 토큰은 ERC20을 기반으로 할 것이다. ERC란 Ethereum request for Comment의 약자로서, 이더리움에서 정한 토큰 표준 스펙이다. 철근, 나사, 못에 국제화된 표준이 있듯이 이더리움에서 채택한 '토큰'에 대한 표준이다. 현재 스테이블 코인을 비롯한 대부분의 토큰은 ERC20을 기반으로 발행되어졌다.

토큰에 대해 이야기 하기 전에, 짚고 넘어가야 할 부분이 있다. A가 B에게 돈을 송금한다고 할 때, 은행이 'A'라고 적혀있던 지폐 뭉치에 이름을 지우고 'B'의 이름을 적는 것이 아니다. 단지 데이터 상으로 A의 잔고(Balance)에서 -10000, B의 잔고에서 +10000 이라는 값이 추가가 될 뿐이다.

ERC20 토큰도 마찬가지이다. A가 B에게 토큰을 전송한다고 해서, 지갑에서 지갑으로 토큰이 직접 이동하는 것이 아니다. 단지 토큰 컨트랙트에 데이터가 기록되는 것이다. 아래처럼 사용자의 지갑 주소와 사용자의 잔고가 매핑되어 기록된다.
mapping(address -> uint)
토큰을 전송한다는 것은 당사자의 mapping에서 보낸 사람은 보낸 양 만큼을 빼고, 받은 사람은 받은 양 만큼을 더하는 것 뿐이다.

    function transfer(address from, address to, uint256 amount) internal {
        _balances[from] = _balances[from].sub(amount);
        _balances[to] = _balances[to].add(amount);
        emit Transfer(from, to, amount);

가장 단순한 형태의 transfer. 보다시피 sender의 balance에서 amount를 빼고, recipient의 balance에서 amount를 더한다.

토큰의 전송은 이런 방식으로 이루어진다. 토큰 데이터는 하나의 스마트 컨트랙트 하나에 존재하며, 마치 독립적인 데이터베이스와 같다. 다시 말해 토큰 전송 트랜젝션을 콘트랙트에 전송한다는 것은, 스마트 컨트랙트에 기록된 데이터를 변경해달라고 요청하는 것과 같다.

ERC20 토큰 표준은 아래와 같은 6가지 기능을 필수로 가져야 한다.
1. totalSupply : 토큰의 전체 공급량을 보여주는 기능
2. balanceOf(owner) : owner의 잔고를 보여주는 기능
3. transfer(to, amount) : 트랜잭션을 실행시킨 주소에서 amount만큼 to 에게 토큰을 전송하는 기능
4. transferFrom(from, to, amount) : from에서 amount 만큼 to 에게 토큰을 전송하는 기능
5. approve(spender, amount) : 트랜잭션을 실행시킨 주소에서 amount 만큼 spender가 토큰을 사용할 수 있도록 승인(approve)하는 기능
6. allowance(owner, spender) : owner가 spender의 잔고 중 어느 만큼을 사용할 수 있는지에 대한 정보를 보여주는 기능

4, 5, 6에 대해 좀 더 자세히 살펴보자면, 이런 예시를 들 수 있다.
"철수는 매달 공과금을 납부한다. 매 달 신경쓰는게 귀찮았던 철수는 영희를 시켜서 대신 납부할 수 있도록 한다. 철수는 영희가 통장에서 1년치 공과금(12만원)을 꺼내갈 수 있게 허용했고, 영희는 철수에게 허락을 받은 12만원만큼만 철수의 통장에서 꺼내어 납부할 수 있게 되었다."

이 때 철수가 영희에게 12만원을 쓸 수 있게 승인하는 과정이 approve이다.
철수가
approve(영희, 12만원)
을 실행시키면, 철수가 영희를 '승인'했다는 데이터가 컨트랙트에 allowance의 형태로 기록된다
이 기록은
allowance(철수, 영희)
를 실행시켜서 확인할 수 있다. 이에 대한 결과값이 12만원이다. 철수가 영희에게 12만원을 쓸 수 있도록 '허용'했기 때문이다.
영희는
transferFrom(철수, 한국전력공사, 1만원)
을 실행하여 매달 1만원씩 철수의 돈을 한국전력공사에게 납부할 수 있게 되고, 이 때 마다 철수의 balance와 allowance(철수, 영희)는 1만원씩 줄어들게 될 것이다. 이에 대한 코드가 아래와 같다.

    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
        transfer(from, to, amount);
        _approve(from, _msgSender(), _allowances[from][_msgSender()].sub(amount));
        return true;
    }
    // _msgSender() : 트랜잭션을 실행시킨 주체

transferFrom 함수를 실행시키게 되면, transfer 함수를 실행시킴과 동시에 approve 함수를 실행시켜서 allowance를 수정한다.

ERC20의 기본적인 개념은 위와 같다. 토큰의 전송에 대한 표준이 위와 같이 정해져 있기 때문에, 토큰 개발을 할 때 토큰의 기본적인 기능은 고민할 필요가 없다. 게다가 이러한 토큰 표준을 완성도 높게 구현한 라이브러리가 여럿 존재한다. 대표적인 라이브러리가 openzeppelin이다. 앞으로 openzeppelin을 이용하여 여러 기능을 구현할 것이다. 또한 컨트랙트 테스트, 배포, 검증을 hardhat과 hardhat의 여러 플러그인을 통해 진행할 것이다. 

-------

## hardhat 설치하기

NodeJS의 패키지 매니저를 이용하여 hardhat을 설치한다. 엘리시아 프로젝트는 yarn을 사용하기 때문에 yarn을 이용하여 hardhat을 설치한다.

yarn add --dev hardhat

## hardhat 시작하기

yarn hardhat

을 입력하여 하드햇 프로젝트를 시작한다. 프로젝트를 시작하므로
create a sample project
를 선택한다. 그러면 이렇게 프로젝트가 만들어진다. 



































증권형의 장, 단점

장점
1. 자산 유동성 : 작게 쪼개서 팔 수 있다는 뜻은 그만큼 거래가 활성화 될 수 있음을 의미하고, 거래가 활발해질 수 있다.
2. 관리 비용 감소 : 블록체인의 기술적인 특성상 자동으로 거래 관련 정보가 기록되고, 이를 조작하기가 어렵기 때문에 거래 비용이 줄어든다. 또한 블록체인 안에서 '토큰' 의 형태로 자산 교환이 이루어 진다는 것은, 여러 가지 자산을 토큰의 형태로 하나의 통합된 시장에서 거래 할 수 있게 되는 가능성을 열어준다.

우려되는 점, 혹은 장점에 대한 반박
1. 여러 가지 인프라는 이미 기술적으로 자산 유동화를 충분히 할 수 있다. 그럼에도 불구하고 여러 자산들이 생각만큼 유동화 되지 않았던 이유가 기술적인 문제 때문이 아닐 수도 있다는 것이다. 그 이유에는 아래와 같은 것들이 있다.
2. 보수적인 자산 시장 : 부동산, 채권 뿐만 아니라 미술품, 귀금속 등 유동화 가능성을 가진 여러 자신 거래 시장은 상당히 보수적이다. 그들의 입장에서는 혁신을 일으킴과 동시에 리스크를 감당하고 싶어하지 않을 수 있다.
3. 가치 책정이 어려움 : 일반적인 소비재와 다르게 유동화의 대상이 되는 자산은 가치 평가가 어렵다. 유동성이 떨어지기 때문에 가격 형성을 시장에 맡길 수 없다. 감정 평가사와 같이, 가치 측정을 도와주는 주체가 없다면, 어려울 수 있다.



